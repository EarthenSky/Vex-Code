#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, in2,    accelX,         sensorAccelerometer)
#pragma config(Sensor, in3,    accelY,         sensorAccelerometer)
#pragma config(Sensor, dgtl1,  enc1,           sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  enc2,           sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  handsUp,        sensorTouch)
#pragma config(Sensor, dgtl6,  handsDown,      sensorTouch)
#pragma config(Motor,  port2,           handMotors,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           clawMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           frontRightMotor, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           backRightMotor, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           frontLeftMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           backLeftMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           coneArmsRight, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           coneArmsLeft,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          coneArmsLeft2, tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX);

#pragma competitionControl(Competition);
// 9000 is on 0 is off.
#pragma autonomousDuration(9000);
#pragma userControlDuration(9000);

#include "Vex_Competition_Includes.c" //backcode no modify.

void pre_auton() {

}

void setMoveSpeed(int speed) {
	//right side
	motor[frontRightMotor] = speed;
	motor[backRightMotor] = speed;

	//left side
	motor[frontLeftMotor] = speed;
	motor[backLeftMotor] = speed;
}

//0 is stop rotating, positive -> left, negitave -> right.
void setRotSpeed(int speed) {
	//right side
	motor[frontRightMotor] = speed;
	motor[backRightMotor] = speed;

	//left side
	motor[frontLeftMotor] = -speed;
	motor[backLeftMotor] = -speed;
}

void setConePickUpSpeed (int val) {
	motor[coneArmsLeft] = val;
	motor[coneArmsLeft2] = val;
	motor[coneArmsRight] = val;
}

void gyroInitialize ()
{
	SensorType[gyro] = sensorGyro;
	wait1Msec(2000);
	//SensorScale[Gyro] = 260;
	SensorValue[gyro] = 0;
	SensorFullCount[gyro] = 36000;
}

void gyroTurn (int turnDirection, int targetDegrees, int maxPower = 87, int minPower = 22, int timeOut = 4000)
{
	// initialize PD loop variables
	float kp = 0.33; // TO BE TUNED
	int error = targetDegrees;
	int drivePower = 0;

	clearTimer(T2);

	// finish check variables
	bool isAtTarget = false;

	// initialize gyro data variables
	int targetReading = SensorValue[gyro];

	// get gyroscope target reading
	if (turnDirection == 8)
		targetReading += targetDegrees;
	else if (turnDirection == 9)
		targetReading -= targetDegrees;

	// change kp if target is under 20 degree threshold
	if (targetDegrees < 100)  //200
		kp = 0.4;

	// run motors until target is within 1/10 degree certainty
	while (!isAtTarget && time1[T2] < timeOut)
	{
		error = targetReading - SensorValue[gyro]; 	// calculate error
		drivePower = error * kp;	// calculate PD loop output

		// cap between min and max power
		drivePower = drivePower < minPower && drivePower > 0 ? minPower : drivePower > -minPower && drivePower < 0 ? -minPower : drivePower;
		drivePower = drivePower > maxPower ? maxPower : drivePower < -maxPower ? -maxPower : drivePower;

		// send power to motors
		motor[frontLeftMotor] = drivePower;
		motor[backLeftMotor] = drivePower;

		motor[frontRightMotor] = -drivePower;
		motor[backRightMotor] = -drivePower;

		// check for finish
		if (abs(error) > 10) 	// if robot is within 1 degree of target and timer flag is off
			clearTimer(T1);			// start a timer
		if (time1(T1) > 200)	// if the timer is over 250ms and timer flag is true
			isAtTarget = true;	// set boolean to complete while loop
	}
	// stop motors
	setMoveSpeed(0);

	// reset kp
	kp = 0.3;
}

task autonomous2	{

}

//Rotation may or may not work.
task autonomous	{
	/*Init 1*/
	SensorType[gyro] = sensorNone;

	/*Drop Goal*/
	motor[handMotors] = -127;
	wait1Msec(1250);
	motor[handMotors] = 0;

	/*Init 2*/
	gyroInitialize();

	/*Move Forwards*/
	setMoveSpeed(70);
	wait1Msec(2200);
	setMoveSpeed(0);

	/*Pick Up Goal*/
	motor[handMotors] = 127;
	wait1Msec(1250);
	motor[handMotors] = 0;

	/*pull out*/
	setMoveSpeed(-70);
	wait1Msec(2200);
	setMoveSpeed(0);

	/*Rotate 180 Degrees*/
	//gyroTurn(9, 90, 50);

	/*Rotate 180 Degrees*/
	setRotSpeed(110);
	bool exit = false;
	while(exit == false) {
		if(abs(SensorValue[gyro]) >= 180 * 7.5) { setRotSpeed(0); exit = true; }  //180 degrees.
	}

	/*Move To place goal*/
	setMoveSpeed(100);
	wait1Msec(1500);
	setMoveSpeed(0);
	//`````````````````````````````````````````
	/*Drop Goal*/
	motor[handMotors] = -127;
	wait1Msec(1250);
	motor[handMotors] = 0;

	/*Move To place goal*/
	setMoveSpeed(-127);
	wait1Msec(150);

	setMoveSpeed(0);
	wait1Msec(150);

	setMoveSpeed(-127);
	wait1Msec(150);

	setMoveSpeed(0);
	wait1Msec(150);

	setMoveSpeed(-127);
	wait1Msec(1500);

	setMoveSpeed(0);
	wait1Msec(150);

	setMoveSpeed(-127);
	wait1Msec(1500);

	setMoveSpeed(0);
	wait1Msec(150);

}

float speedMod = 1;
int holdClaw = 0;
task usercontrol {
	while(true)
	{
		//goal pickup arm.
		if(vexRT[Btn8R] == 1 && SensorValue[handsUp] == 0)	{
			motor[handMotors] = 127;
		} else if (vexRT[Btn8D] == 1 && SensorValue[handsDown] == 0) {
			motor[handMotors] = -127;
		} else {
			motor[handMotors] = 0;
		}

		//cone pickup arm.
		if(vexRT[Btn5U] == 1)	{
			setConePickUpSpeed(127);
			} else if (vexRT[Btn6U] == 1) {
			setConePickUpSpeed(-127);
			} else {
			setConePickUpSpeed(0);
		}

		//claws
		if(vexRT[Btn6D] == 1)	{
			motor[clawMotor] = 127;
			holdClaw = 1;
		} else if (vexRT[Btn5D] == 1) {
			motor[clawMotor] = -127;
			holdClaw = 0;
		} else {
			//keeps pressure on the cone when picked up.
			if (holdClaw == 1) {
				motor[clawMotor] = 10;
			} else {
				motor[clawMotor] = 0;
			}
		}

		//toggle high speed mode.
		if(vexRT[Btn7U] == 1)	{
			speedMod = 1;
		} else if(vexRT[Btn7D] == 1) {
			speedMod = 2;
		}

		/*tank drive*/
		//right
		motor[frontRightMotor] = vexRT[Ch2] / speedMod;
		motor[backRightMotor]  = vexRT[Ch2] / speedMod;
		//left
		motor[frontLeftMotor] = vexRT[Ch3] / speedMod;
		motor[backLeftMotor]  = vexRT[Ch3] / speedMod;

	}
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
