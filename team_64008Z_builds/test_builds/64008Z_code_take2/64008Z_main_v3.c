#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, in2,    miniGoalPot,    sensorPotentiometer)
#pragma config(Sensor, in5,    lightLeft,      sensorReflection)
#pragma config(Sensor, in6,    lightRight,     sensorReflection)
#pragma config(Sensor, in7,    lightMid,       sensorReflection)
#pragma config(Sensor, dgtl1,  encArm,         sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  handsDown,      sensorTouch)
#pragma config(Sensor, dgtl6,  handsUp,        sensorTouch)
#pragma config(Sensor, dgtl8,  urfOut,         sensorSONAR_inch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           pushGoalHand,  tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           frontLeftDrive, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           frontRightDrive, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           goalHands,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           coneArms,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           backBackLeftDrive, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           backLeftDrive, tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port8,           backBackRightDrive, tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port9,           backRightDrive, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          claw,          tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*Compo Init*/
#pragma platform(VEX);

#pragma competitionControl(Competition);
#pragma autonomousDuration(9000);
#pragma userControlDuration(9000);

#include "Vex_Competition_Includes.c" //backcode no modify pls.

/*Global Constants*/
//#include "64008Z_auto_v2.c" //autonomous code.
const int down = 1;
const int up = 2;
const int mid = 3;
const int completed = 4;

const int dir_forwards = 1;
const int dir_backwards = -1;
const int dir_left = -1;
const int dir_right = 1;

const float mod_degrees = (278 / 360) * 10;  //multiply this with degrees to get
const float mod_wheel_circumference = 4 * 3.1415926535897932; //in inches.  (that's right, I memorized that many characters...)
const int task_time_limit = 2000;  //2s

bool inTeleop = false;

///initialize the gyroscope
void gyroInit() {
	//writeDebugStreamLine("Gyro Reset.");
	SensorType[gyro] = sensorNone;
	wait1Msec(1000);

	//writeDebugStreamLine("Gyro Assign..");
	SensorType[gyro] = sensorGyro;
	wait1Msec(2000);

	//writeDebugStreamLine("Gyro Setup...");
	//SensorScale[gyro] = 278;  //?
	SensorValue[gyro] = 0;
	SensorFullCount[gyro] = 3600;  //not working? gyro is auto set to 3600. dunno dont care.
}

//TODO: TEST THIS.
///direction = up(const) for up move and down(const) for down move.
int armParam = 0;
task autoMoveGoalArms() {
	clearTimer(T4);

	if(armParam == up) {
		motor[goalHands] = 127;
    waitUntil(SensorValue[handsUp] == 1 || time1(T4) >= task_time_limit);
	}
	else(armParam == down) {
		motor[goalHands] = -127;
    waitUntil(SensorValue[handsDown] == 1|| time1(T4) >= task_time_limit);
	}

  armParam = completed;

	motor[goalHands] = 0;
}

//TODO: TEST THIS.
//sensorPotentiometer:
const int pot_up = 4095;
const int pot_down = 1905;
const int pot_no_ground = 2150;

//not super accurate (doesn't need to be.)
int miniArmParam = 0;
task autoMoveMiniGoalArms() {
	clearTimer(T3);

	if(miniArmParam == up) {
		motor[pushGoalHand] = 127;
    waitUntil(SensorValue[miniGoalPot] >= pot_up || time1(T3) >= task_time_limit);  //insert up pos here
	}
	else if(miniArmParam == down) {
		motor[pushGoalHand] = -127;
    waitUntil(SensorValue[miniGoalPot] <= pot_down || time1(T3) >= task_time_limit);  //insert down pos here
	}
	else if (miniArmParam == mid) {
		if(SensorValue[miniGoalPot] < pot_no_ground) {
			motor[pushGoalHand] = 127;
			waitUntil(SensorValue[miniGoalPot] >= pot_no_ground || time1(T3) >= task_time_limit);
		}
		else {
			motor[pushGoalHand] = -127;
			waitUntil(SensorValue[miniGoalPot] <= pot_no_ground || time1(T3) >= task_time_limit);
		}
	}

  miniArmParam = completed;

	motor[pushGoalHand] = 0;
}

//not super accurate (doesn't need to be.)
int coneArmParam = 0;
void autoScoreCone() {
	int ticksInPlace = 0;

 	while (ticksInPlace <= 3) {  //3 ticks //TODO: set to 2 ticks? (faster).
	 	armError = degToMove + SensorValue[encArm];  //finds distance left to go
	 	armSpeed = armError * armKp;

	 	setConePickUpSpeed(armSpeed);

		//TODO: tune this.
		if(abs(armError) > 0.5) {  //checks for end timer. needs to be within 0.5 degrees of target.
			ticksInPlace = 0;
		}
		else {
			ticksInPlace++;
		}

		wait1Msec(20);  //60hz
 	}

	motor[claw] = 127; //open
	wait1Msec(200);

	setConePickUpSpeed(100); //done.
	wait1Msec(200);

	setConePickUpSpeed(0); //done.
}

//sets the speed of the left and right sides of the drive.  Empty is not moving.
void setLeftRightMoveSpeed(int leftSpeed=0, int rightSpeed=0) {
  //calculate deadzone.
  if(abs(leftSpeed) < 5) { leftSpeed = 0; }
  if(abs(rightSpeed) < 5) { rightSpeed = 0; }

	//left side.
	motor[frontLeftDrive] = leftSpeed;
  motor[backLeftDrive] = leftSpeed;
  motor[backBackLeftDrive] = leftSpeed;

	//right side.
	motor[frontRightDrive] = rightSpeed;
	motor[backRightDrive] = rightSpeed;
	motor[backBackRightDrive] = rightSpeed;

	//writeDebugStreamLine("L - R is %d - %d", leftSpeed, rightSpeed); //DEBUG: this
}

void resetEncoders() {
	nMotorEncoder[backLeftDrive] = 0;
	nMotorEncoder[backRightDrive] = 0;
}

void moveStraightGyro(float inches, const int negitaveMod=dir_forwards, int maxTimeout=5000, int maxPower=102, int minPower=17) {
	float disKp = 0.25;  //distance kp.  //was 0.22
	float gyroKp = 1.4;

	float error = 0;
	float gyroError = SensorValue[gyro];

	int sideMod = 0;
  float speed = 0;

	clearTimer(T2);  //start timer

	//init encoders
	resetEncoders();

	bool exitLoop = false;
	while(exitLoop == false && time1(T2) < maxTimeout) {
		float encAvgLR = (abs(nMotorEncoder[backLeftDrive]) + abs(nMotorEncoder[backRightDrive])) / 2;

		error = abs(inches / mod_wheel_circumference * 360) - encAvgLR;  //how close to completed.
    speed = error * disKp;

    writeDebugStreamLine("speed is %d, error2 is %d", speed, error); //DEBUG: this

    gyroError -= SensorValue[gyro];
    sideMod = gyroError * gyroKp;

    //keep speed between min and max power.
    if(speed < minPower && speed > 0) {
  		speed = minPower;
  	} else if(speed > -minPower && speed < 0) {
      speed = -minPower;
    }

  	if(speed > maxPower) {
  		speed = maxPower;
  	} else if(speed < -maxPower) {
      speed = -maxPower;
    }

		setLeftRightMoveSpeed((speed * sideMod) * negitaveMod, (speed * -sideMod) * negitaveMod);  //move forwards (also does straightening)

		// check for finish
		if (abs(error) > 5) 	// if robot is within 5 degree wheel rotations and timer flag is off
			clearTimer(T1);			// start a timer

		if (time1(T1) >= 90)	// if the timer is over 90ms and timer flag is true (3 ticks)
			exitLoop = true;	// set boolean to complete while loop

		wait1Msec(20);  //loop speed.  //60hz
	}

	setLeftRightMoveSpeed(); //turn off motors.

  //reset again, just in case.
	resetEncoders();

	return;  //this?
}

/*Gyro Turn*/
//run PD loop to turn to target deg.
void gyroTurn (int turnDirection, int targetDegrees, int maxPower=75, int minPower=23, int timeOut=3000) {
	// initialize PD loop variables
	float kp = 0.21; // TODO: tune this.
	int error = targetDegrees;
	int drivePower = 0;

	clearTimer(T2);

	// finish check variables
	bool atTarget = false;

	// initialize gyro data variables
	int targetReading = SensorValue[gyro];

	// get gyroscope target reading
	if (turnDirection >= 1)
		targetReading += targetDegrees;
	else if (turnDirection <= 0)
		targetReading -= targetDegrees;

	// change kp if target is under 20 degree threshold
	if (targetDegrees < 200) { kp = 0.2; }  //ok?

	// run motors until target is within 1 degree certainty
	while (!atTarget && (time1[T2] < timeOut)) {
		error = targetReading - SensorValue[gyro]; 	// calculate error
		drivePower = error * kp;	// calculate PD loop output  //speed

		writeDebugStreamLine("error -> %d, gyro -> %d", error, SensorValue[gyro]);  //DEBUG: this

		//keep speed between min and max power.
		if(drivePower < minPower && drivePower > 0) {
			drivePower = minPower;
		}
		else if(drivePower > -minPower && drivePower < 0) {
      drivePower = -minPower;
    }

		if(drivePower > maxPower) {
			drivePower = maxPower;
		}
		else if(drivePower < -maxPower) {
    	drivePower = -maxPower;
    }

		//send power to motors. //(also does straightening)
		setLeftRightMoveSpeed(-drivePower, drivePower);

		// check for finish
		if (abs(error) > 8) 	// if robot is within 0.8 degree off target and timer flag is off
			clearTimer(T1);			// start a timer

		if (time1(T1) > 150)	// if the timer is over 150ms and timer flag is true
			atTarget = true;	// set boolean to complete while loop

		wait1Msec(20);  //let motors update.
	}

	setLeftRightMoveSpeed();  //reset motors.

	// reset kp  wtf is this?  TODO: delete?
	kp = 0.22;

	resetEncoders();
  return; //I think I need this.
}

///the real autonomous command.
void runAutoSkills() {

  ///So far code moves robot to pick up and place two goals
  ///this gives 30 pts?.
  ///

	/*Drop goal arm & mini goal arm + Drive into G1*/
	armParam = down; startTask(autoMoveGoalArms);
  miniArmParam = down; startTask(autoMoveMiniGoalArms);
	moveStraightGyro(42, dir_forwards);

  /*Large goal up + Drive into G2*/
  armParam = up; startTask(autoMoveGoalArms);
  moveStraightGyro(36, dir_forwards);

  /*Mini goal up + Drive into P1*/
  miniArmParam = up; startTask(autoMoveMiniGoalArms);
  moveStraightGyro(31.2, dir_forwards);

  /*Rotate 90 deg left*/
  gyroTurn(dir_left, 90 * mod_degrees);

  /*Drive to P2*/
  moveStraightGyro(16.56, dir_forwards);

  /*Rotate 90 deg right*/
  gyroTurn(dir_right, 90 * mod_degrees);

  /*Drive to 20pt goal almost*/
  moveStraightGyro(20.76, dir_forwards);

	/*move to middle*/
	miniArmParam = mid; startTask(autoMoveMiniGoalArms);

	/*Drive to 20pt goal*/
  moveStraightGyro(9, dir_forwards);

  /*Mini goal down*/
  miniArmParam = down; startTask(autoMoveMiniGoalArms);

  /*Pull back into 10pt goal*/
  moveStraightGyro(12.36, dir_backwards);

  /*Large goal down*/
  armParam = down; startTask(autoMoveGoalArms);
  waitUntil(armParam == completed);

  /*Pull back to P2*/
  moveStraightGyro(17.4, dir_backwards);

	/**************************************/

  /*Ore wo dare da to omotte yagaru?!*/
}

void runAutoCompBottom() {

  ///So far code gets 9/9 pts, gets one goal in 5 pts and parks.  TODO: test.

	/*Raise cone arm*/
	setConePickUpSpeed(-80);
	wait1Msec(60);  //3 ticks.

	/*Drop goal arm & mini goal arm + Drive into G5*/
	armParam = down; startTask(autoMoveGoalArms);
  miniArmParam = down; startTask(autoMoveMiniGoalArms);
	moveStraightGyro(57.6, dir_forwards);

	/*Stop cone arm*/
	setConePickUpSpeed(0);

  /*Large goal up*/
  armParam = up; startTask(autoMoveGoalArms);
  waitUntil(armParam == completed);

  /*Rotate 180 deg left*/
  gyroTurn(dir_left, 180 * mod_degrees);

	/*Score cone*/
	autoScoreCone();

  /*Drive into 5pt goal*/
  moveStraightGyro(50.4, dir_forwards);

  /*Large goal down*/
  armParam = down; startTask(autoMoveGoalArms);
  waitUntil(armParam == completed);

  /*Pull back and park*/
  moveStraightGyro(50.4, dir_backwards);

  /*Ore wo dare da to omotte yagaru?!*/
}

//has a rotation different.
void runAutoCompTop() {

  ///So far code gets 9/9 pts, gets one goal in 5 pts and parks.  TODO: test.

	/*Raise cone arm*/
	setConePickUpSpeed(-80);
	wait1Msec(60);  //3 ticks.

	/*Drop goal arm & mini goal arm + Drive into G5*/
	armParam = down; startTask(autoMoveGoalArms);
  miniArmParam = down; startTask(autoMoveMiniGoalArms);
	moveStraightGyro(57.6, dir_forwards);

	/*Stop cone arm*/
	setConePickUpSpeed(0);

  /*Large goal up*/
  armParam = up; startTask(autoMoveGoalArms);
  waitUntil(armParam == completed);

  /*Rotate 180 deg right*/
  gyroTurn(dir_right, 180 * mod_degrees);

	/*Score cone*/
	autoScoreCone();

  /*Drive into 5pt goal*/
  moveStraightGyro(50.4, dir_forwards);

  /*Large goal down*/
  armParam = down; startTask(autoMoveGoalArms);
  waitUntil(armParam == completed);

  /*Pull back and park*/
  moveStraightGyro(50.4, dir_backwards);

  /*Ore wo dare da to omotte yagaru?!*/
}

void pre_auton() {
	gyroInit();
}

task autonomous	{
	//this calls the autonomous script.
	runAutoComp();
}

const float armKp = 1.5;
const int degToMove = -100;
float armError = 0;
int armSpeed = 50;

bool isGoalArmMovingDown = false;

bool inDropPos = false;
bool moveArmToDrop = false;

bool isHoldingClaw = false;
bool clawClosed = false;

task coneDrop { wait1Msec(500); moveArmToDrop = false; }  //drops the cone.

task usercontrol {
	writeDebugStreamLine("***************Start************");
	writeDebugStreamLine("***************Start************");
	writeDebugStreamLine("***************Start************");
	writeDebugStreamLine("***************Start************");

	//auto tests go here.

	writeDebugStreamLine("Done");
	inTeleop = true;
  resetMoveMod(); //just no encs during user k?
	while(true) {
		/*Large Goal Arm*/
		if(vexRT[Btn8R] == 1)	{
			isGoalArmMovingDown = true;
		} else if (vexRT[Btn8D] == 1 ) {
			isGoalArmMovingDown = false;
		}

		if(isGoalArmMovingDown == true && SensorValue[handsDown] == 0) {
			motor[goalHands] = -127;
		} else if (isGoalArmMovingDown == false && SensorValue[handsUp] == 0){
			motor[goalHands] = 127;
		} else {
			motor[goalHands] = 0;
		}

		/*Cone Arm*/
		if(vexRT[Btn5U] == 1)	{
			motor[coneArms] = 100;
		} else if (vexRT[Btn5D] == 1) {
			motor[coneArms] = -100;
		} else {
			motor[coneArms] = 0;
		}

		/*Move Arm to Drop Pos*/
		if(vexRT[Btn8U] == 1) {
			if(inDropPos == false) { moveArmToDrop = true; }
			inDropPos = true;
		} else {
			inDropPos = false;
		}

		/*Claws (negitave is closed)*/
		if(vexRT[Btn6U] == 1)	{
			isHoldingClaw = false;
			motor[claw] = 127;

			if(clawClosed == false) {  //stop arm movement is called once when the button is first pressed.
				if(moveArmToDrop == true) { startTask(coneDrop); }
			}
			clawClosed = true;

		} else if (vexRT[Btn6D] == 1) {
			isHoldingClaw = true;
			motor[claw] = -127;
		} else {
			clawClosed = false;
			//keeps pressure on the cone when picked up.
			if(isHoldingClaw == true) {
				motor[claw] = -20;  //TODO: change value down or up if pressure is wrong.
			} else {
				motor[claw] = 0;
			}
		}

		/*Mini Goal*/
		if(vexRT[Btn7L] == 1)	{
			motor[pushGoalHand] = 127;
		} else if(vexRT[Btn7D] == 1) {
			motor[pushGoalHand] = -127;
		} else {
			motor[pushGoalHand] = 0;
		}

		/*Tank Drive*/
		setLeftRightMoveSpeed(vexRT[Ch3], vexRT[Ch2]);

		/*Auto Move Arm To Drop Pos*/
		if(moveArmToDrop == true) {
			armError = degToMove + SensorValue[encArm];  //finds distance left to go
			armSpeed = armError * armKp;

			setConePickUpSpeed(armSpeed);
		}

		//writeDebugStreamLine("gyro is %d", SensorValue[gyro]);  //DEBUG: this

		//let everything update
		wait1Msec(20);  //TODO: remove?
	}
}
