#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, in2,    miniGoalPot,    sensorPotentiometer)
#pragma config(Sensor, in5,    lightLeft,      sensorReflection)
#pragma config(Sensor, in6,    lightRight,     sensorReflection)
#pragma config(Sensor, in7,    lightMid,       sensorReflection)
#pragma config(Sensor, dgtl1,  encArm,         sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  handsDown,      sensorTouch)
#pragma config(Sensor, dgtl6,  handsUp,        sensorTouch)
#pragma config(Sensor, dgtl8,  urfOut,         sensorSONAR_inch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           pushGoalHand,  tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           frontLeftDrive, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           frontRightDrive, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           goalHands,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           coneArms,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           backBackLeftDrive, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           backLeftDrive, tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port8,           backBackRightDrive, tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port9,           backRightDrive, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          claw,          tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//warning code is slightly agressive.

/*Compo Init*/
#pragma platform(VEX);

#pragma competitionControl(Competition);
#pragma autonomousDuration(9000);
#pragma userControlDuration(9000);

#include "Vex_Competition_Includes.c" //backcode no modify pls.

/*Other Scripts*/
//#include "64008Z_auto_v2.c" //autonomous code.
const string down = "down";
const string up = "up";

const float degreeMod = 278 / 360;

bool inTeleop = false;

float currentTick = 0;

//

int roundToInt(float f) {  //rounds value to int.
  if(f>0)
  	return (int)(f + 0.5);
  else
  	return (int)(f - 0.5);
}

///initialize the gyroscope
void gyroInit() {
	writeDebugStreamLine("Gyro Reset.");
	SensorType[gyro] = sensorNone;
	wait1Msec(1000);

	writeDebugStreamLine("Gyro Assign..");
	SensorType[gyro] = sensorGyro;
	wait1Msec(2000);

	writeDebugStreamLine("Gyro Setup...");
	//SensorScale[gyro] = 2;  // try this
	SensorValue[gyro] = 0;
	SensorFullCount[gyro] = 3600;  //not working? gyro is auto set to 3600.
}

//TODO: TEST THIS.
///direction = up(const) for up move and down(const) for down move.
string armDirection = "null";
task autoMoveGoalArms() {
	if(armDirection == up) {
		motor[goalHands] = 127;
    waitUntil(SensorValue[handsUp] == 1);
	}
	else {
		motor[goalHands] = -127;
    waitUntil(SensorValue[handsDown] == 1);
	}

	motor[goalHands] = 0;
}

string miniArmDirection = "null";
task autoMoveMiniGoalArms() {
	if(miniArmDirection == up) {
		motor[pushGoalHand] = 127;
    waitUntil(SensorValue[miniGoalPot] < 15);  //insert up pos here
	}
	else {
		motor[pushGoalHand] = -127;
    waitUntil(SensorValue[miniGoalPot] > 1);  //insert down pos here
	}

	motor[pushGoalHand] = 0;
}

///sets cone pickup speed.  Empty is not moving.
void setConePickUpSpeed (int val=0) {
	motor[coneArms] = val;
}

float kp = 2;

float errorVal = 0;

float leftMod = 0;
float rightMod = 0;
void straightenMotors() {
  //set offset value, if 0 both sides are moving at same speed.  use abs value for both motors, pretending both sides going forwards.
  errorVal = (abs(nMotorEncoder[backLeftDrive]) - abs(nMotorEncoder[backRightDrive]));

  //update both modifiers.
  rightMod = (errorVal * kp);
  leftMod = -rightMod;

  writeDebugStreamLine("mod = error[%d] * kp[%d] = +[%d] -> at tick %d", errorVal, kp, leftMod, currentTick);  //DEBUG: this
  //writeDebugStreamLine("The error of (L - R) is %d degrees -> at tick %d", errorVal, currentTick);  //DEBUG: this
}

void resetMoveMod () { leftMod = 2; rightMod = -2; }  //small func.

//*VERY IMPORTANT*: THIS MUST BE CALLED FOR STRAIGHTENING TO OCCUR.
//sets the speed of the left and right sides of the drive.  Empty is not moving.
void setLeftRightMoveSpeed(int leftSpeed=0, int rightSpeed=0) {
  if (inTeleop == false) {
    straightenMotors();
  }  //make sure not to straighten motors while in teleop.  Don't fuck with Victor.

  //calculate deadzone.
  if(abs(leftSpeed) < 5) { leftSpeed = 0; }
  if(abs(rightSpeed) < 5) { rightSpeed = 0; }

	//left side, add positive mod (mod is scaled pased on speed).
	motor[frontLeftDrive] = abs(leftSpeed) + leftMod * (abs(leftSpeed)/127);
  motor[backLeftDrive] = abs(leftSpeed) + leftMod * (abs(leftSpeed)/127);
  motor[backBackLeftDrive] = abs(leftSpeed) + leftMod * (abs(leftSpeed)/127);
  //if negitave, make negitave.
  if(leftSpeed < 0) {
    motor[frontLeftDrive] *= -1;
    motor[backLeftDrive] *= -1;
    motor[backBackLeftDrive] *= -1;
  }

	//right side, add positive mod (mod is scaled based on speed).
	motor[frontRightDrive] = abs(rightSpeed) + rightMod * (abs(rightSpeed)/127);
	motor[backRightDrive] = abs(rightSpeed) + rightMod * (abs(rightSpeed)/127);
	motor[backBackRightDrive] = abs(rightSpeed) + rightMod * (abs(rightSpeed)/127);
  //if negitave, make negitave.
  if(rightSpeed < 0) {
    motor[frontRightDrive] *= -1;
    motor[backRightDrive] *= -1;
    motor[backBackRightDrive] *= -1;
  }

	//writeDebugStreamLine("L - R is %d - %d", leftSpeed + leftMod, rightSpeed + rightMod); //DEBUG: this
}

void resetEncoders() {
	nMotorEncoder[backLeftDrive] = 0;
	nMotorEncoder[backRightDrive] = 0;
}

float encLVal = 0;
float encRVal = 0;

float error = 0;
//moves straight
void moveRotations(float rotations, int negitaveMod=1, int maxPower=70, int minPower=12, int maxTimeout=3000) {
	//bool isForwards = false;
	//float kp = 0.07;  //new kp
	float kp = 0.22;  //new kp
	bool exitLoop = false;

	encLVal = 0;
	encRVal = 0;

	clearTimer(T3);  //start timer

	error = 0;

  float speed = 0;

	//init encoders
	nMotorEncoder[backLeftDrive] = 0;
	nMotorEncoder[backRightDrive] = 0;

	while(exitLoop == false && time1(T3) < maxTimeout) {
    encLVal = abs(nMotorEncoder[backLeftDrive]);
    encRVal = abs(nMotorEncoder[backRightDrive]);

		error = abs(rotations * 360) - encLVal;  //how close to completed.
    speed = error * kp;
    writeDebugStreamLine("speed is %d, error2 is %d", speed, error); //DEBUG: this

    //keep speed between min and max power.
    if(speed < minPower && speed > 0) {
  		speed = minPower;
  	} else if(speed > -minPower && speed < 0) {
      speed = -minPower;
    }

  	if(speed > maxPower) {
  		speed = maxPower;
  	} else if(speed < -maxPower) {
      speed = -maxPower;
    }

		setLeftRightMoveSpeed(speed * negitaveMod, speed * negitaveMod);  //move forwards (also does straightening)

		/*if (error <= 0) { //case: loop is done motor is at (or past) correct position.
			//exitLoop = true; //loop exit.
		}*/

		// check for finish
		if (abs(error) > 5) 	// if robot is within 5 degree wheel rotations and timer flag is off
			clearTimer(T1);			// start a timer

		if (time1(T1) >= 90)	// if the timer is over 90ms and timer flag is true (3 ticks)
			exitLoop = true;	// set boolean to complete while loop

    currentTick++;  //DEBUG: to find ticks
		wait1Msec(30);  //loop speed.
	}

	currentTick = 0;

	setLeftRightMoveSpeed(); //turn off motors.

  //reove distance that was supposed to be moved.
	nMotorEncoder[backLeftDrive] -= negitaveMod * abs(rotations * 360);
	nMotorEncoder[backRightDrive] -= negitaveMod * abs(rotations * 360);

	return;
}

float wheelRadius = 4 * 3.1415926535897932; //in inches.  (that's right, I memorized that many characters...)
void moveInches(float value, int negitaveMod=1) {
	moveRotations(value / wheelRadius, negitaveMod);  //converts inches to rotations.
}

bool hitLine = false;
task lookForLine {
	//set hitLine to not have been hit.
	hitLine = false;
	while (hitLine == false) {
		//look for the line.

		//if found line hitLine = true;
	}
}

// **GYRO TURN**
// target (in degrees) is added/subtracted from current gyro reading to get a target gyro reading
// run PD loop to turn to target
// checks if target has been reached AND is at target for over 250ms before moving on
void gyroTurn (int turnDirection, int targetDegrees, bool isDirectValue=false, int maxPower=80, int minPower=23, int timeOut=3000) {
	// initialize PD loop variables
	float kp = 0.22; // TO BE TUNED
	int error = targetDegrees;
	int drivePower = 0;

	clearTimer(T2);

	// finish check variables
	bool atTarget = false;

	// initialize gyro data variables
	int targetReading = SensorValue[gyro];

	// get gyroscope target reading
	if (turnDirection >= 1)
		targetReading += targetDegrees;
	else if (turnDirection <= 0)
		targetReading -= targetDegrees;

	// change kp if target is under 20 degree threshold
	if (targetDegrees < 200) { kp = 0.2; }  //ok?

	// run motors until target is within 1 degree certainty
	while (!atTarget && (time1[T2] < timeOut)) {
		error = targetReading - SensorValue[gyro]; 	// calculate error
		drivePower = error * kp;	// calculate PD loop output  //speed

		writeDebugStreamLine("error -> %d, gyro -> %d", error, SensorValue[gyro]);  //DEBUG: this

		//keep speed between min and max power.
		if(drivePower < minPower && drivePower > 0) {
			drivePower = minPower;
		}
		else if(drivePower > -minPower && drivePower < 0) {
      drivePower = -minPower;
    }

		if(drivePower > maxPower) {
			drivePower = maxPower;
		}
		else if(drivePower < -maxPower) {
    	drivePower = -maxPower;
    }

		//send power to motors. //(also does straightening)
		setLeftRightMoveSpeed(-drivePower, drivePower);

		// check for finish
		if (abs(error) > 8) 	// if robot is within 0.8 degree off target and timer flag is off
			clearTimer(T1);			// start a timer

		if (time1(T1) > 150)	// if the timer is over 200ms and timer flag is true
			atTarget = true;	// set boolean to complete while loop

		wait1Msec(20);  //let motors update.
	}

	setLeftRightMoveSpeed();  //reset motors.

	// reset kp  wtf is this?  TODO: delete?
	kp = 0.22;

	resetEncoders();
  return; //I think I need this.
}

//value is in inches.
//precision is for how accurate the value is going to be.  More accurate -> longer time to get value.
float getRFDistance (int precision=5, int pollingTime=40) {
	float sumDistances = 0;  //holds all of the distances from the rangefinder.

	for (int i = 0; i < precision; i++) {
		sumDistances += SensorValue[urfOut];  //fetch!  Good boy!

		wait1Msec(pollingTime);  //longer pollingTime means longer to get values.  Too quick and cortex cant keep up / gives same number.  Sensor polling is 3ms.
	}

	return sumDistances / precision;
}

///the real autonomous command.
void runAuto() {
	/*Drop Goal Arms and Drive Into G1*/
	armDirection = down;
	startTask(autoMoveGoalArms);

	/*Move Forwards One Rotation*/
	moveRotations(1, 100);

	/**/
}

void pre_auton() {
	gyroInit();
  string startgame = "fun";  //Do not remove or script doesn't work anymore, I dunno why.
}

task autonomous	{
	//DEBUG: just test code now.

	//gyroTurn(-1, 3600);


	/*moveRotations(6);
	wait1Msec(2000);

	moveRotations(6, -1);
	wait1Msec(2000);

	moveRotations(6);
	wait1Msec(2000);

	moveRotations(6, -1);
	wait1Msec(2000);*/

	runAuto();  //this calls the autonomous script.
}

float armError = 0;
int armSpeed = 50;
int degToMove = 170;

bool tempLock = false;
bool isHoldingClaw = false;
bool isGoalArmMovingDown = false;
bool inDropPos = false;
bool moveArmToDrop = false;
task usercontrol {
	writeDebugStreamLine("***************Start************");
	writeDebugStreamLine("***************Start************");
	writeDebugStreamLine("***************Start************");
	writeDebugStreamLine("***************Start************");
	resetEncoders();

	//moveRotations(2);
	//wait1Msec(1000);

	//moveRotations(2, -1);
	//wait1Msec(1000);

	//moveRotations(2);
	//wait1Msec(1000);

	//moveRotations(2, -1);
	//wait1Msec(1000);*/

	//gyroTurn(1, 90);

	//gyroTurn(-1, 2780);
	//wait1Msec(1000);

	//gyroTurn(1, 3600 * degreeMod);
	//wait1Msec(1000);

	writeDebugStreamLine("Done");
	inTeleop = true;
  resetMoveMod(); //just no encs during user k?
	while(true) //TODO: set to true so loop goes.
	{
		/*Goal Arm*/
		if(vexRT[Btn8R] == 1)	{
			isGoalArmMovingDown = true;
		}
		else if (vexRT[Btn8D] == 1 ) {
			isGoalArmMovingDown = false;
		}

		if(isGoalArmMovingDown == true && SensorValue[handsDown] == 0) {
			motor[goalHands] = -127;
		}
		else if (isGoalArmMovingDown == false && SensorValue[handsUp] == 0){
			motor[goalHands] = 127;
		}
		else {
			motor[goalHands] = 0;
		}

		/*Cone Arm*/
		if(vexRT[Btn5U] == 1)	{
			setConePickUpSpeed(110);
		}
		else if (vexRT[Btn5D] == 1) {
			setConePickUpSpeed(-110);
		}
		else {
			setConePickUpSpeed();
		}

		/*Move Arm to Drop Pos*/
		if(vexRT[Btn8U] == 1) {
			if(inDropPos == false) { moveArmToDrop = true; }
			inDropPos = true;
		}
		else {
			inDropPos = false;
		}

		/*Claws*/
		if(vexRT[Btn6U] == 1)	{
			motor[claw] = 127;
			isHoldingClaw = false;
		}
		else if (vexRT[Btn6D] == 1) {
			motor[claw] = -127;
			isHoldingClaw = true;
		}
		else {
			//keeps pressure on the cone when picked up.
			if(isHoldingClaw == true) {
				motor[claw] = -10;  //TODO: change value down or up if pressure is wrong.
			}
			else {
				motor[claw] = 0;
			}
		}

		if(vexRT[Btn7L] == 1)	{
			motor[pushGoalHand] = 127;
		}
		else if(vexRT[Btn7D] == 1) {
			motor[pushGoalHand] = -127;
		}
		else {
			motor[pushGoalHand] = 0;
		}

		/*Tank Drive*/
		setLeftRightMoveSpeed(vexRT[Ch3], vexRT[Ch2]);

		if(vexRT[Btn7U] == 1)	{
			setLeftRightMoveSpeed(127, 127);
		}

		if(vexRT[Btn7L] == 1)	{
			setLeftRightMoveSpeed(-127, -127);
		}

		/*Auto Move Arm To Drop Pos*/
		float armKp = 2.2;
		if(moveArmToDrop == true) {
			armError = degToMove - SensorValue[encArm];  //finds distance left to go
			armSpeed = armError * armKp;

			setConePickUpSpeed(armSpeed);

			if(armError < 0.5 && armError > 0.5) {  //If within 0.5 degrees of pos.
				while (moveArmToDrop == true) {  //take out while loop
					//TODO: drop cone?
					motor[claw] = -127;
					wait1Msec(1000);
					motor[claw] = 0;
					moveArmToDrop = false;
				}
			}
		}

		//let everything update
		wait1Msec(20);
	}
}
